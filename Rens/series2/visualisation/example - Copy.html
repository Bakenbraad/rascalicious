<!DOCTYPE html>
<meta charset="utf-8"/>
<style>
.node {
  font: 10px sans-serif;
}

.node:hover {
  fill: #1f77b4;
}

.link {
  stroke: steelblue;
  stroke-opacity: 0.5;
  fill: none;
  pointer-events: none;
}

.link.source, .link.target {
  stroke-opacity: 1;
  stroke-width: 2px;
}

.node.target {
  fill: #000000 !important;
}

.link.source {
  stroke: #000000;
}

.node.source {
  fill: #000000;
}

.link.target {
  stroke: #000000;
}
</style>
<body>
<div id="bundle"></div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script type="text/javascript" src="//code.jquery.com/jquery-1.12.3.min.js"></script>
<script>

	var diameter = 960,
		radius = diameter / 2,
		innerRadius = radius - 120,
		m0,
		rotate = 0,
		pi = Math.PI;
		
	var splines = [],
		bundle = d3.layout.bundle();
	
	var cluster = d3.cluster()
		.size([360, innerRadius]);
		
	var line = d3.radialLine()
		.curve(d3.curveBundle.beta(0.85))
		.radius(function(d) { return d.y; })
		.angle(function(d) { return d.x / 180 * Math.PI; });
		
	var svg = d3.select("body").append("svg")
		.attr("width", diameter)
		.attr("height", diameter)
		.append("g")
		.attr("transform", "translate(" + radius + "," + radius + ")")
		
	var link = svg.append("g").selectAll(".link"),
		node = svg.append("g").selectAll(".node");
		
	d3.json("flare.json", function(error, classes) {
		if (error) throw error;
		
		var root = packageHierarchy(classes)
			.sum(function(d) { return d.size; });
			
		cluster(root);
		
		var nodes = cluster(root),
		//nodes2 = cluster.nodes(packages.root(classes)
		links = packageImports(nodes),
		splines = bundle(links);
		
		link = link		
			.data(packageImports(root.leaves()))
			.enter().append("svg:path")
			.each(function(d) {
				d.source = d[0];
				d.target = d[d.length-1];
			})
			.attr("class", function(d) { return "link source-" + d.source.key + " target-" + d.target.key; })
			.attr("d", line);
			
		var path = svg.selectAll("path.link")
			.data(links)
			.enter().append("svg:path")
			.attr("class", function(d) { return "link source-" + d.source.key + " target-" + d.target.key; })
			.attr("d", function(d, i) { return line(splines[i]); });

		
		node = node
			.data(root.leaves())
			.enter().append("text")
			.attr("class", "node")
			.attr("dy", "0.31em")
			.attr("id", function(d) { return "node-" + d.key; })
			.attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + (d.y + 8) + ",0)" + (d.x < 180 ? "" : "rotate(180)"); })
			.attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
			.text(function(d) { return d.data.key; })
			.on("mouseover", mouseover)
			.on("mouseout", mouseout);
	});
	
	// Lazily construct the package hierarchy from class names.
	function packageHierarchy(classes) {
		var map = {};
		function find(name, data) {
			var node = map[name], i;
			if (!node) {
				node = map[name] = data || {name: name, children: []};
				if (name.length) {
					node.parent = find(name.substring(0, i = name.lastIndexOf(".")));
					node.parent.children.push(node);
					node.key = name.substring(i + 1);
				}
			}
			return node;
		}
	
		classes.forEach(function(d) {
			find(d.name, d);
		});
		
		return d3.hierarchy(map[""]);
	}
	
	// Return a list of imports for the given array of nodes.
	function packageImports(nodes) {
	
		var map = {},
		imports = [];
		
		// Compute a map from name to node.
		nodes.forEach(function(d) {
			map[d.data.name] = d;
		});
		
		// For each import, construct a link from the source to target node.
		nodes.forEach(function(d) {
			if (d.data.imports) d.data.imports.forEach(function(i) {
				imports.push(map[d.data.name].path(map[i]));
			});
		});
	
		return imports;
	}	
	
	function mouse(e) {
		return [e.pageX - radius, e.pageY - radius];
	}
	
	var div = d3.select("#bundle")
		.style("width", diameter + "px")
		.style("height", diameter + "px")
		.style("position", "absolute");
	
	function mouseover(d) {
		console.log(d.data.key);
		svg.selectAll("path.link.target-" + d.data.key)
			.classed("target", true)
			.each(updateNodes("source", true));

		svg.selectAll("path.link.source-" + d.data.key)
			.classed("source", true)
			.each(updateNodes("target", true));
	}
	
	function mouseout(d) {
	
		console.log(d);
		
		svg.selectAll("path.link.source-" + d.data.key)
			.classed("source", false)
			.each(updateNodes("target", false));

		svg.selectAll("path.link.target-" + d.data.key)
			.classed("target", false)
			.each(updateNodes("source", false));
	}
	
	function updateNodes(name, value) {
		console.log(value);
		return function(d) {
			if (value) this.parentNode.appendChild(this);
			svg.select("#node-" + d[name].key).classed(name, value);
		};
	}
	
	function cross(a, b) {
		return a[0] * b[1] - a[1] * b[0];
	}

	function dot(a, b) {
		return a[0] * b[0] + a[1] * b[1];
	}

	function findStartAngle(children) {
		var min = children[0].x;
		children.forEach(function(d) {
			if (d.x < min)
				min = d.x;
		});
		return min;
	}

	function findEndAngle(children) {
		var max = children[0].x;
		children.forEach(function(d) {
		   if (d.x > max)
			   max = d.x;
		});
		return max;
	}
	
</script>
</body>